# Vault in Managed Kubernetes

## Описание.
Пример работы с Vault в Managed Kubernetes.

## Установка Vault.
```
export HELM_EXPERIMENTAL_OCI=1 && \
cat /Users/cameda/practicum/key.json | helm registry login cr.yandex --username 'json_key' --password-stdin && \
helm pull oci://cr.yandex/yc-marketplace/yandex-cloud/vault/chart/vault \
  --version 0.28.1+yckms \
  --untar && \
helm install \
  --namespace hcv \
  --create-namespace \
  --set-file yandexKmsAuthJson=/Users/cameda/practicum/key.json \
  --set yandexKmsKeyId=abjcqs5ra87t18f97jt7 \
  --set "injector.enabled=false" \
  --set "csi.enabled=true" \
  hashicorp ./vault/
```

helm status hashicorp -n vault
helm get manifest hashicorp -n vault
```
--------------------------------------------------------------------------------------------------------------------

## Инициализируем оператор.
```
kubectl exec -ti -n vault hashicorp-vault-0 -- vault operator init
```

Полученные данные обязательно сохраняем!
```
Recovery Key 1: ynX59J/1GchlMupo+4r0UNTihJxbjAMUaTRPVdNXAtJY
Recovery Key 2: uT6zOjmhALFeamaghSnJBOEpqhgnDCwc+KqteYaA1d2P
Recovery Key 3: /SJSpcsXpRO5ql7Hk/dyvsBMGUZ8x5XTsWIS/ja5Q7dp
Recovery Key 4: 79Jon9b3+hFsrRhzCV6flVLYQbGkC8YzSsdTRxao6xU1
Recovery Key 5: jmkYa21DvGqC8tIP7VRP6vWHN8IAR7rbIPzw0mNulLi+

Initial Root Token: hvs.MfU5MUmkzldLW9VBxxd2zz7C
```
--------------------------------------------------------------------------------------------------------------------
```
kubectl exec -ti -n vault hashicorp-vault-0 -- vault operator unseal
```
* Вводим один из Recovery Key. Ввёл первый - ynX59J/1GchlMupo+4r0UNTihJxbjAMUaTRPVdNXAtJY.
```
Unseal Key (will be hidden):
Key                      Value
---                      -----
Seal Type                yandexcloudkms
Recovery Seal Type       shamir
Initialized              true
Sealed                   false
Total Recovery Shares    5
Threshold                3
Version                  1.17.2+yckms
Build Date               2024-07-19T13:33:51Z
Storage Type             file
Cluster Name             vault-cluster-a75cdc66
Cluster ID               afef1a85-4cf7-cf70-d725-de53fb966394
HA Enabled               false
```
--------------------------------------------------------------------------------------------------------------------
```
kubectl exec -ti -n vault hashicorp-vault-0 -- vault login
Token (will be hidden):
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                hvs.MfU5MUmkzldLW9VBxxd2zz7C
token_accessor       fx0GIt8F8HInni5dobjlHv1d
token_duration       ∞
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]
```
--------------------------------------------------------------------------------------------------------------------

### Создаём секрет в Vault.
```
kubectl exec -ti -n vault hashicorp-vault-0 -- vault secrets enable -path=secret kv
kubectl exec -ti -n vault hashicorp-vault-0 -- vault kv put secret/db-pass password="12345678"

kubectl exec -ti -n vault hashicorp-vault-0 -- vault kv get secret/db-pass
====== Data ======
Key         Value
---         -----
password    12345678
```
--------------------------------------------------------------------------------------------------------------------

### Включаем метод аутентификации Kubernetes.
```
kubectl exec -ti -n vault hashicorp-vault-0 -- vault auth enable kubernetes
kubectl exec -ti -n vault hashicorp-vault-0 -- vault write auth/kubernetes/config \
   kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443"
```
--------------------------------------------------------------------------------------------------------------------

### Создаём политику, разрешающую чтение секрета db-pass и свяжем её с SA. 
```
kubectl exec -ti -n vault hashicorp-vault-0 -- vault policy write internal-app - <<EOF
path "secret/db-pass" {
  capabilities = ["read"]
}
EOF
```

### Настроим связь политики и SA с именем webapp-sa.
```
kubectl exec -ti -n vault hashicorp-vault-0 -- vault write auth/kubernetes/role/database \
   bound_service_account_names=webapp-sa \
   bound_service_account_namespaces=hcv \
   policies=internal-app \
   ttl=20m
```

## Установим драйвер SCI и SA.
```
helm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts
helm install csi secrets-store-csi-driver/secrets-store-csi-driver \
   --namespace=vault \
   --set syncSecret.enabled=true

kubectl -n vault get pods -l "app=secrets-store-csi-driver"
kubectl create serviceaccount webapp-sa -n vault
```

## Создаём SecretProviderClass, связывающий БД Vault и сущности кубера.

```
cat <<EOF | kubectl apply -f -
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: vault-database
  namespace: hcv
spec:
  provider: vault
  parameters:
    vaultAddress: "http://hashicorp-vault.hcv:8200"
    roleName: "database"
    objects: |
      - objectName: "db-password"
        secretPath: "secret/db-pass"
        secretKey: "password"
EOF
```
## Пример использования. Монтируем vault-database.
```
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: webapp
  namespace: hcv
spec:
  # serviceAccountName: webapp-sa
  containers:
  - image: jweissig/app:0.0.1
    name: webapp
    volumeMounts:
    - name: secrets-store-inline
      mountPath: "/mnt/secrets-store"
      readOnly: true
  volumes:
    - name: secrets-store-inline
      csi:
        driver: secrets-store.csi.k8s.io
        readOnly: true
        volumeAttributes:
          secretProviderClass: "vault-database"
EOF
```
